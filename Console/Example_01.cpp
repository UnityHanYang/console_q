// 한줄 주석 : 코드에는 영향을 주지 않는다. -> 내가 또는 타인을 위한 메모

/*
단위 주석
*/
#pragma region 메인함수
/*
() {} []
void : 공허하다. main()
함수라고 불리는 친구

메인 함수는 하나만 존재한다.
ㄴ E.P => C/C++ 언어로 작성되어 있는 프로그램이 처음 실행되는 부분 => C#도 동일

C/C++언어는 프로그램이 처음 실행되기 위해서 반드시 main()함수를 포함하고 있어야 한다.
ㄴ 진입점이 되는 포인트이기 때문에 해당 함수가 존재하지 않을 경우 프로그램 자체가
실행되지 않는다.

C/C++ 언어가 프로그램으로 변환되기 위해서 거치는 과정

- 전처리기

- 컴파일

- 링크
*/
#pragma endregion 여기도 가능

// 전처리 지시문
// #: 명령 지시자
// #pragma는 지시문, 그 뒤에 붙는 것(region)이 수행할 명령

#pragma region 프로그래밍 언어
/*
▶ 프로그래밍이란?
 
- Programming, Program에 Ing가 붙였으니 지금 프로그램을 하고 있다라고 직역할 수 있다.
 ㄴ 지금 프로그램을 하고 있다라는 것은 결국 프로그램을 만드는 것 => 개발을 의미한다.

▶ 프로그래밍 언어란?

- 컴퓨터와 대화 또는 명령을 할 수 있는 일련의 명령문을 작성할 수 있는 언어를 의미한다.
ㄴ 프로그래밍 언어를 활용하면 프로그램을 만드는 것이 가능하다.

- 프로그래밍 언어에는 다양한 언어가 존재하지만 크게 2가지로 분류할 수 있다.
ㄴ 1. 특징 기능 구현에 최적화 된 언어 (JavaScript, C# Script)
ㄴ 2. 범용적 언어 (C++)

▶ 프로그래밍 언어를 컴퓨터에서 이해하는 방법

- C/C++ 언어로 작성되어 있는 코드는 컴퓨터가 이해할 수 없는 명령문이기 때문에
C/C++ 언어는 중간에서 언어를 해석해 주는 무언가가 필요하다.

※ 그게 바로 컴파일러
	ㄴ 컴파일러는 해당 코드를 컴퓨터가 이해할 수 있는 언어로 변환하는 역할을 수행한다.

※ 즉, 컴파일러가 프로그래밍 언어와 컵퓨터가 사이에서 통역사 역할을 한다.
그렇기 때문에 프로그래밍 언어를 작성하는 사람은 컴퓨터 언어를 모른다 하더라도 명령을 내리는 것이 가능하다.

※ 컴파일러 != 인터프리터
ㄴ != : 같지 않다.
ㄴ == : 같다.

C/C++은 범용적이긴 하지만 컴파일러가 포함돼 있기 때문에 웹 등등..에서 사용되지 않는다.
	ㄴ 컴파일러가 통영을 하고 데이터를 서로에게 넘겨주기 때문에 느리다(무거움).

M(High Level Language, 인터프리터 언어) : C#
U(Low Level Language, 컴파일러 언어) : C/C++
레벨이 높을 수록 사람이 이해할 수 있는 언어고
레벨이 낮을 수록 컴퓨터가 이해할 수 있는 언어다.

M은 무겁진 않지만 상급을 뽑아내고 싶을 때 사용 됨(개발 기간이 짧음)
U는 그래픽 등등 무거운 방식에 사용 됨(개발 기간이 김)
M이 좋고 U가 안 좋다가 아니고 상황에 따라서 다름

▶ 프로그래밍 기술 및 기법

- 프로그래밍 기술은 점차 발전해 왔고 앞으로도 발전해 나갈 것이다.
ㄴ 현재는 크게 4가지로 분류해서 파악을 해두면 좋다.

★★ 면접 문제 ★★

1. 순차적 프로그래밍 (절차지향) 대표적인 언어 : C

- 프로그래밍 언어 초기부터 사용된 기법
ㄴ 코드의 흐름에 따라 프로그래밍 하는 기술
ㄴ 프로그램의 실행부터 종류까지의 흐름을 그래도 프로그래밍 한다.
ㄴ 이 방식은 프로그램의 흐름을 따라가기 때문에 가독성이 좋을 때도 있지만 일반적으로 구조적이지
못하고 코드가 여기저기 흩어져 있기 때문에 유지보수가 아주 어렵다.

2. 구조적 프로그래밍 (함수지향)

- 순차적 프로그래밍의 단점을 보완하기 위해 나온 방식으로 코드의 구조를 기능 단위로 묶는 방식

- 함수 지향 프로그래밍이라고도 부르며 순차적 프로그래밍 보다는 유지보수가 용이하다는 장점 존재
	ㄴ 문제가 생기거나 유지보수가 필요할 때 그 부분만 집중적으로 보면 되기 때문

- 이러한 기능들을 한 곳에 묶어 모듈이라는 형태로 만들게 되고 이는 프로그래밍 라이브러리로
발전하게 된다.

3. 객체지향 프로그래밍

- 위에 두 방식과는 전혀 다른 방식으로 코드의 기준을 "객체"단위로 묶어 프로그래밍 하는 기법

- 모든 대상에는 속성과 메서드가 있고 이를 하나로 묶어 객체로 만드는 방식이며 여기에서 말하는
대상에는 눈에 보이지 않는 것도 포함이 된다.

- 객체지향 기법에는 상속 / 다형성 / 추상화 / 캡슐화 등등이 있지만 그건 나중에...

4. 컴포넌트 프로그래밍

- 코딩의 기준을 객체가 아닌 컴포넌트 단위로 프로그래밍 하는 방식

- 각각의 컴포넌트는 독립적으로 움직이는 부품과 같으므로 다리를 떼서 동물에게 붙여주면 걷거나
달리는 것이 가능하게 되며 너희가 배우게 될 Unity Engine이 컴포넌트 기반으로 베이스가 잡혀있다.

- 다양한 컴포넌트가 존재하고 이것을 추가하는 것만으로 원하는 기능을 쉽게 구현할 수 있다.

*/
#pragma endregion

// 헤더 파일
#include <iostream>
// ㄴ C++에서 입 / 출력을 담당하는 표준 라이브러리
// #include 키워드는 해당 경로에 있는 파일의 내용을 단순하게 복사를 하는 역할을 수행한다.
// 표준 해더 파일은 <이렇게> 사용한다.
// stream : 여러 장치에 입 출력 작업이 실행되는 것을 추상화 하여 나타낸 것
//	ㄴ 연결해주는 통로를 만들어주는 것(vs에서 아무런 상관이 없는 터미널을 실행하는 것 같이)
//  ㄴ 여러 장치(폴더, 터미널 등등)
//  ㄴ 기능: cout / cin / endl
// cout => console output, cin => console input, endl => end line

#include <Windows.h>
// ㄴ 구버전 헤더 파일 -> c언어 헤더 파일

//#include "MainGame.h"
// ㄴ 사용자 정의 헤더 파일, 즉 본인이 만들었다.

// std: 표준
// std라는 이름 안에 정의되어 있는 것을 그냥 사용하겠다.
// ㄴ 이름 공간 std에 선언된 것은 std라는 이름 공간의 선언없이 접근하겠다는 선언 지시
// ㄴ 프로그래밍에서는 신경을 쓰지 않으면 이름 충돌이 반드시 발생한다. -> 컴파일 에러
//	  이름 공간 std에 선언된 모든 것에 접근할 때는 이름 공간 지정을 생략하겠다.
using namespace std;

void TextColor(int font, int backGround);

void main() {
	/*
	▶ 코드 작성의 기본
	ㄴ 빨간색 밑줄을 보게 된다면

	1. 오타 체크

	2. 앞, 뒤를 체크할 것

	3. ;를 체크할 것

	4. 논리적으로 성립이 되는지 깊은 고민이 필요하다.
	ㄴ 시간이 필요한 파트

	*/
	// 1. (컴퓨터 상에선 1번이 제일 빠르고 좋음)
	//		ㄴ 메모리 덜 사용, 2번 보다 속도가 빠름
	std::cout << "나는 피곤하다" << std::endl;
	// cout: 출력해라
	// endl: 줄을 바꾼다. (개행)

	// <<: 출력 연산자
	// C: printf() / C++: cout

	// >>: 입력 연산자
	// C: scanf() / C++: cin


	// 2.
	cout << "나는 피곤하다" << endl;

	cout << "문자 출력: " << "쌍따옴표 안에 적으면 된다." << endl;
	
	cout << "숫자 출력: " << 12345 << " 그냥 숫자 적어보자?" << endl;

	// 1. A: 문자
	// 2. ABC: 문자열
	cout << "★" << endl;

	// 심플한 자기소개 출력
	// ㄴ 이름 / 나이 / 연락처 / 주소 / 이메일 / 각오 / 가고 싶은 회사나 연봉 / 만들고 싶은 게임\
		/ 취미
	
	cout << "지옥에 온 걸 환영해!" << endl;
	printf("지옥에 온걸 환영해!\n");

	/*
	- C언어 서식 문자(printf / scanf)
	
	- 서식문자는 문자열을 출력 또는 입력을 받을 때 해당 서식 문자의 자리를 다른 수로 대체하기 위한 자리 매김 역할을
	하는 문자를 의미한다.

	서식 문자를 이용하면 고정되어 있지 않는 문자열을 출력 또는 입력 받는 것이 가능하다.

	- 서식 문자의 종류 (느껴 => 외워 => 손이 기억한다)

	- %d: int형, 정수를 대체하는 용도
	- %ld: long형, 정수를 대체하는 용도
	- %lld, long long형, 정수를 대체하는 용도
	- %c: char형, 문자를 대체하는 용도
	- %s: 문자열 입력
	- %f: float형, 실수를 대체하는 용도
	- %lf: double형, 실수를 대체하는 용도

	printf 특수문자
	
	- \n: 개행
	- \t: 수평
	- \v: 수직
	- \\: \
	- \?: ?
	- \': '
	- \": "
	*/
	printf("%d", 3333333333333);
	cout << "\n";
	printf("%f", 1.1111111111111111);
	cout << "오늘 날씨는 내가 \"너무\" 좋아하는 날씨야 나는 비를 \"정말\" 좋아하거든" << endl;

	cout << "이름: 박환의\n" << "나이: 20(만 18)\n" << "연락처: 010-2901-8209\n" << "주소: 서울특별시 강동구\n" << "이메일: pkhan89@gmail.com\n" << "각오: 열심히 노력해서 원하는 회사에 가겠습니다\n" << "원하는 회사: 시프트업" << endl;
	cout << "만들고 싶은 게임: 쯔꾸르, mmorpg\n" << "취미: 게임" << endl;

	TextColor(4, 15);
	cout << "⇔⇔⇔⇔⇔⇔⇔⇔⇔" << endl;
	
}

void TextColor(int font, int backGround) {
	int color = font + backGround * 16;
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);
}
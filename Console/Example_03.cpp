#include <iostream>

using std::cout;
using std::endl;
using std::cin;

#pragma region 연산자 + 반복문
/*
▶ 연산자란?

- 프로그램이 동작할 때 정해져 있는 특정 역할을 수행하는 키워드를 연산자라고 한다.
 ㄴ 연산자를 이용하면 다양한 프로그램 로직을 만들어내는 것이 가능하다.

 ▷ 기본적인 연산자의 종류

 - 산술 연산자 (+, -, *, /, %)
 - 비교 연산자 (==, !=, <, >, <=, >=)
 - 할당 연산자 (+=, -=, *=, /=, %=)
 - 비트 연산자 (&, |, ^)
 - 논리 연산자
 - 형변환 연산자


▶ 산술 연산자

+: 더하기

-: 빼기

*: 곱하기

/: 나누기
ㄴ 몫을 남김, 나머지를 버림

%: 나머지
ㄴ 몫을 버림, 나머지를 남김


▶ 비교 연산자

num == num2;         ->  num과 num2가 같다.
num != num2;         ->  num과 num2가 같지 않다.
num < num2;          ->  num이 num2보다 작다.
num > num2;          ->  num이 num2보다 크다.
num <= num2;         ->  num이 num2보다 작거나 같다.
num >= num2;         ->  num이 num2보다 크거나 같다.


▶ 할당 연산자

=: 대입 연산자 (결합 방향: 우 -> 좌)

- +=
- -=
- *=
- /=
- %=


▶ 비트 연산자

 - 상태값 / 색상값 검출

 - 효율적 메모리 사용과 빠른 연산이 장점

 &
 |
 ^
 ~
 <<
 >>

플레이어 상태 이상(독, 출혈, 경직 등등)을 표현할 때 사용 됨

※ 공부하다가 bitset -> 탈출

★★★ 면접 질문 ★★★ (C언어 스타일 형변환의 문제점, 단점을 물어봄)
▶ 형변환 연산자

- ((특정 자료형)) 변수형
 ㄴ int value = 0;
 ㄴ (float)value;

 형변환의 문제점: int에서 float으로 바뀔 땐 문제가 없는데, float에서 int로 변환 중에 소수점이 버려져서 데이터가 손실된다.
 앞에 (자료형)이 붙으면 C언어의 형변환이다
 가장 큰 문제점은 앞에 강제가 붙는다 -> 강제형변환
 EX: 가챠 시스템에 0.000025% 확률을 강제 형변환해서 확률을 1%로 바뀌면서 문제가 난다.
 그래도 속도가 빠르다는 장점이 있다.


- C/C++ 언어는 형변환 연산자를 이용하면 간단하게 해당 변수의 자료형을 변경하는 것이 가능하다.

▶ 강제 형변환에 대해서

- C스타일의 명시적(어떤 타입으로 바꿔줄지 추상적이지 않게 보여줌) 형변환은 기본적으로 가독성이 떨어지고 버그가 생길 여지가 다분하다.
 ㄴ "강제"로 형을 바꿔주기 때문
 ㄴ 속도를 챙길 것이면 C스타일로 / 안정성을 챙길 것이라면 C++

 EX:
 static_cast<int>(obj) -> obj를 type으로 바꾸겠다.
 ㄴ 단. 논리적으로 가능한 경우에만 변환 수행 -> 안정성 UP

 C++ 타입 캐스팅 연산자 시리즈
 - static_cast (v)
 - dynamic_cast
 - const_cast
 - reinterpret_cast


▶ 반복문이란?

- 프로그램의 특징 부분을 일정 횟수 이상 반복해서 실행하도록 하기 위한 문법
ㄴ 반복문을 이용하면 반복적으로 발생되는 구간을 효율적 / 간단하게 처리하는 것이 가능하다.
	ㄴ 문법을 잘 활용하면 편리함과 효율성이 수직 상승

반복문의 종류

1. for문

- 구성
ㄴ 초기식: 반복을 위한 변수의 선어너 및 초기화 수행
ㄴ 조건식: 반복의 조건을 검사하는 목적으로 선언
ㄴ 증감식: 반복을 조건을 거짓으로 만드는 증가 및 감소 연산

EX)
for(초기식; 조건식; 증감식)
{
	반복이 되는 문장
}

※ 초기값은 맨 처음에 한 번만 수행이 되고 조건식이 참인 동안만 명령문을 반복 수행한다.
반복의 횟수가 정해져 있을 때 가장 베스트


2. while문

- 무한 (loop): 반복 조건에 1(참)이 들어갈 경우 무한 루프에 빠지게 된다.
	ㄴ 조건이 true(참)일 때만 작동
	ㄴ 후에 배울 제어문으로 빠져나올 수 있다.

- while문은 특정 조건을 주고 그 조건을 만족하는 동안 특정 영역을 계속해서 반복하는 구조

※ while문은 반복의 조건을 거짓으로 만드는게 가장 중요하다.

3. do ~ while문

- while문과의 차이점: 조건을 검사하는 시점이 다르다.
ㄴ 일단 무조건 한 번 실행 후 while문의 조건을 검사하여 do ~ while문 안의 문장을
실행할 것인지에 대해 판단한다.

※ 반복문들은 기본적으로 중첩이 가능하다.
반복문은 중첩을 할 수록 코스트가 더 나간다.
 ㄴ 3중 반복문 부터는 코스트가 세다 -> 무겁다


	*/
#pragma endregion

void main() {

	int numberA = 0;
	numberA = 1;
	numberA++;
	numberA = 6;
	numberA++;
	numberA += 5;
	numberA--;
	numberA -= 2;
	numberA *= 3;
	numberA /= 2;

	cout << "numberA의 값: " << numberA << endl;


	/*
	C/C++ 언어는 연산자를 이용해서 결과를 만들어낼 때 해당 연산자에 사용된 변수의 자료형에
	따라서 결과가 달라진다.

	EX)
	정수 + 정수 = 정수
	정수 + 실수 = 실수

	기본적으로 연산자를 사용할 때는 동일한 자료형의 변수를 가지고 연산을 하는 것이 원칙이다.
	하지만 서로 자료형이 다를 경우 연산자에 의한 데이터의 결과는 값을 소실 할 수 있는 위험이
	적은 자료형으로 만들어진다.

	단, 나머지 연산자는 정수형 데이터만 사용하는 것이 가능하다.


	*/

	// C스타일 -> 컴파일러 버전에 따라 유동적
	/*int i;
	for (i = 0; i < 10; i++)
	{
		cout << "[" << i << "번째]공부하고 인내하면 너희도 개발자" << endl;
	}*/

	cout << "\n";

	/*int numberB = 0;
	for (; numberB < 5; numberB++)
	{
		cout << "이렇게 사용을 하면...? " << endl;
	}*/

	printf("\n");

	/*
	- for문은 필요에 따라 초기식, 조건식, 증감식 생략이 가능하다.

	생략 유형

	1. 초기화 생략 -> for(; i < 10; i++) // 멀티게임에서 플레이어가 들어오고 게임을 시작할 때 그 플레이어 수만큼 정해두고 게임시작 전 로딩창에서 정해둔 플레이어 수를 초기식에 넣어둔다.
	2. 조건식 생략 -> for(i = 1; ; i++)
	3. 중감식 생략 -> for(; i < 10;)
	4. 모두 생략 -> for(; ;);


	*/

	// i++: 후위: 세미콜론을 만나고 나서 개행이 되고 실행
	// ++i: 전위: 세미콜론을 만나기 전(개행을 하기 전)에 실행
	//int j = 1;
	// 객체지향 스탕딜 (C++)
	//for (int i = 0; i < 5; i++)
	//{
	//	cout << "첫번째 값은? " << ++j << endl;
	//	cout << "두번째 값은? " << j++ << endl;
	//}

	// ★ 면접 문제 ★
	// 출력 버퍼 중 출력 순서는?
	cout << '\n'; //1등
	cout << "\n"; // 2등
	printf("\n"); // 3등           가변적 함수(복사를 한다 -> 느리다)
	cout << endl; // 4등          endl: 템플릿



	//실습
	// ㄴ 1. 1 ~ 10까지 출력 / 2. 10 ~1까지 출력 => 2가지를 해본다.
	// ㄴ 3. 구구단 찍기 (2단 ~ 9단) / 4. 구구단이 출력이 되면 가로로 3단씩 출력

	//for (int i = 1; i < 11; i++)
	//{
	//	cout << i << endl;
	//}

	//cout << endl;

	//for (int i = 10; i > 0; i--) {
	//	cout << i << endl;
	//}

	//cout << endl;

	//for (int i = 2; i < 10; i++)
	//{
	//	for (int j = 1; j < 10; j++) {
	//		cout << i << " x " << j << " = " << i * j << endl;;
	//	}
	//}

	//cout << endl;

	//int i = 2;
	//int j = 1;
	//int max = 5;
	//int count = 2;
	//for (int m = 0; m < 3; m++) {
	//	for (int k = 0; k < 9; k++) {
	//		for (; i < max; i++)
	//		{
	//			for (; j < j + 1; j++)
	//			{
	//				cout << i << " x " << j << " = " << i * j << " ";
	//				break;
	//			}
	//		}
	//		cout << endl;
	//		i = count;
	//		j++;
	//	}
	//	cout << endl;
	//	j = 1;
	//	max += 3;
	//	max = (max > 10) ? 10 : max;
	//	count += 3;
	//	i = count;
	//}

	//// 02. while문

	int playerHp = 1000;
	
	while (playerHp > 0)
	{
		int hit = 100; //맴버 변수
		playerHp -= hit;
		cout << "체력 = " << playerHp << endl;
	}

	//cout << '\n';

	//int numC = 0;

	//while (numC < 5) {
	//	cout << "while문이 돌아간다" << endl;
	//	numC++;
	//}

	//cout << '\n';

	cout << "while문 구구단" << endl;

	int m = 2;
	while (m < 10) {
		int k = 1;
		cout << m << "단 출력" << endl;
		while (k < 10) {
			cout << m << " * " << k << " = " << m * k << '\n';
			k++;
		}
		cout << '\n';
		m++;
	}

	/*
	do{
	}while(조건식);
	*/

	int numD = 0;

	do {
		cout << "do ~ while문" << endl;
		numD++;
	} while (numD < -1);

	cout << '\n';


	do {
		cout << "2번째 do ~ while문" << endl;
		numD++;
	} while (numD < 3);

	cout << '\n';

	// 그래서? -> 너는 언제 쓰는데?

	int total = 0, num = 0;
	do {
		cout << "숫자를 입력해라. (단, 0을 입력하면 프로그램을 종료하겠다.)" << endl;
		cin >> num;
		total += num;
	} while (num != 0);

	cout << "숫자의 합 좀 보여줘: " << total << endl;

	cout << '\n';

	//while문의 문제점: do while엔 1번을 실행시키고 while (num != 0) 라는 조건을 만나게 되는데
	// while문은 while (num != 0) 조건에서 거짓이 되어 버려서 while 내부로 들어갈 수가 없다.
	// 게임으로 비유하면 던전에 입장하려고 할 때 "던전에 입장하시겠습니까?" 라고 물어보는 문구가 나오고 ok, no 버튼이 나온다
	// 이럴 때 1번 이상은 사용이 됐다는 뜻이니까 do while을 쓴다

	/*
	▶ while문과 do ~ while문의 차이점

	- 반복문의 횟수가 정해져 있다.
	ㄴ 자연스럽게

	- 반복의 횟수가 정해져 있지 않다.
	ㄴ 이럴 때는 고민이 필요하다.

	※ 위에 do ~ while문을 while문으로 바꾸면 프로그램은 바로 종료된다.
		ㄴ num = 0; 임으로.

	- 코딩 스타일
	ㄴ 1. 주도적 / 2. 방어적 / 3. 순응하며 갈 것인지
	1 -> 유니티에서 c#을 사용하는 방식
	2 -> c/c++을 사용하는 방식 -> 신입들이 사용하기 좋은 방식
	*/

	// 실습
	// ㄴ do ~ while 구구단

	int gNum1 = 2;
	do {
		cout << gNum1 << "단" << endl;
		int gNum2 = 1;
		do {
			cout << gNum1 << " * " << gNum2 << " = " << gNum1 * gNum2 << '\n';
			gNum2++;
		} while (gNum2 < 10);
		cout << '\n';
		gNum1++;
	} while (gNum1 < 10);

	for (int i = 1; i < 12; i++)
	{
		//printf("%c%c%c%c%c%c%c%c%c%c%c%c\n", i % 11 = 5, i % 11, i % 11);
	}

	/*char c = ' ';
	for (int i = 1; i <= 30; c = (i == 3 || i == 8 || ))
	{
		cout << c;
	}

	for (int i = 0, j = 0; i < 66; i++, (6 - ((1 % 6) + 1 == 0 ? j++ : j)))
	{
		(i / 36) < 1 ? (6 - ((i % 6) + 1) <= j)...
	}*/
}


/*
과제1. 연산자 활용

a. 두 개의 정수를 받아서 두 수의 덧셈과 뺄샘의 결과를 출력하는 프로그램 작성

b. 3개의 정수(num1, num2, num3)를 받아서 다음 연산의 결과를 출력하는 프로그램 작성

ㄴ EX: (num1 + num2) * (num3 + num1) % num1 = ?

c. 입력 받은 두 정수를 나누었을 때 얻게 되는 몫과 나머지를 출력하는 프로그램 작성
ㄴ EX: 7과 2가 입력되면 몫으로 3, 나머지는 1이 출력되면 OK

과제2. 별찍기

- 총 5가지를 해올 것
ㄴ 분해된 4가지 / 완성된 것 1가지

*****
****
***
**
*

     **      // 5
	****     // 4
   ******    // 3
  ********   // 2
 **********  // 1
************ // 0
 **********  // 1
  ********   // 2
   ******    // 3
	****     // 4
	 **      // 5



도전과제1. 마름모 찍기

-조건: for문 1번 + 1줄 -> for(){ 1줄 ) 반복문 안에 1줄만 쓰기
ㄴ 조건문 x

// 수식에서 처리 x
for(int i = 1; i < 12; i++)
{
	반복문 내부 처리
}

한줄 조사. 조건문

- 노트에 적어온다.

- 비유할 것 생각해 온다.
ㄴ EX: 조건문은 000이다.

*/

#include <iostream>

using namespace std;

#pragma region MyRegion
/*
▶ 전처리기

- 실행파일을 생성하는 과정에서 컴파하기 직전, 소스 파일 내에 존재하는 선행 처리 지시문을
처리하는 작업을 의미한다.

- 전처리가 실행되면 각 코드 파일에서 지시자를 찾는다.
ㄴ 지시자는 #으로 시작해서 줄 바꿈으로 끝나는 코드

※ 선행 처리를 위한 명령에는 맨 앞에 #기호가 붙는다는 공통점이 있다.

▷ C/C++ 코드를 실행하는 과정

- 전처리기 -> 컴파일러 -> 어셈블러 -> 링커

	1. 전처리기 (Preprocessor)
	ㄴ 헤더파일 삽입, 코드의 주석 제거, 문법 검토, 매크로등을 치환하는 기능을 한다.

	2. 컴파일러
	ㄴ. 어셈블리 파일로 변환한다.

	3. 어셈블리 -> 유니티에도 있음, 쓸 줄만 알면 최적화가 가능하다
	ㄴ 어셈블리 코드를 기계어(0 or 1)로 변환하여 오브젝트 파일을 생성한다

	4. 링커
	ㄴ 각각의 오브젝트 파일들을 묶어서 실행 코드 파일로 변환한다.

- 소스코드 -> 바이너리 -> 실행 파일

  디테일

1. 내가 작성한 소스파일은 먼저 소스파일 처리를 하는 선행 처리기를 거치고
2. 컴파일 되어
3. 오브젝트 파일이 생성되고
4. 링커에 의해 실행 파일이 만들어 진다.

이 과정을 컴퓨터가 다 처리해주는 언어가 c#


▶ 선행처리를 위한 명령

- 전처리기문 = 전처리기 연산자

- 파일 처리를 위한 전처리기문

1. #include
#include <파일 이름>
ㄴ 표준 라이브러리 (미리 정의된 include 폴더에서 파일을 찾는다)
#include "파일 이름" -> 파일 이름에 c언어의 구버전과 cpp를 둘다 사용하고 싶을 때 hpp를 사용한다 ex) "파일 이름.hpp"
ㄴ 사용자 정의 헤더 파일 (현재의 소스 코드가 지정되어 있는 폴더에서 먼저 찾고,
						파일이 없다면 미리 정의된 include 폴더에서 파일을 찾는다.)


   형태 정의를 위한 전처리기문

1. #define // (include, define, undef, 조건부 컴파일 시리즈들, pragma) 중에 define의 사용 빈도가 압도적으로 높음
ㄴ define 키워드는 매크로 상수 또는 매크로 함수를 정의하는 키워드

2. #undef
ㄴ 매크로를 해제해 주는 키워드

 - 조건부 컴파일 시리즈들
 
 1. #if, #ifdef, #ifndef, #else, #elif, #endif -> 원하는 부분에 컴파일을 하려면 선행적 역할을 해줘야 하는데 그 역할을 하는 친구들
 
 #ifdef: 식별자가 정의되어 있으면 참

 #ifndef: 식별자가 정의되어 있지 않다면 참

 #endif: #if or #ifdef or #ifndef에 대한 전처리기 부분을 종료

 객체지향: 설계기법이지 문법이 아님.
 ㄴ c언어도 객체지향을 만들 수 있다.

 객체지향에서도 선택적 컴파일을 사용할 수 있다.

 ※ 코드 설계에서 잘 적용이 된다면 실행 속도에 따른 큰 이득을 볼 수 있다.
 ㄴ 선택적 컴파일 수행할 것이기 때문

 
  pragma

- 컴파일러의 기능을 확장시킬 수 있게 나온 문법
ㄴ 어떠한 동작 / 행위를 정해주기 위해 사용한다.

- 사용 중인 컴파일러의 버전 / os에 다라 동작 여부가 갈린다.
ㄴ 윈도우 코드는 윈도우만 / 리눅스 코드는 리눅스

#pragma once: 링크가 수행될 때 해더 파일이 한 번만 포함되게 한다.

#pramga region
-> 코드를 개요 / 축소가 가능하게 묶어주는 기능

#pramga endregion

#pragma message("Example_05_C.cpp 수정 금지")
ㄴ 컴파일시 출력창에 메시지 출력
ㄴ 주로 협업시 / 혹시 본인이 한 중요한 작업 까먹지 않게 기입할 때 사용한다.

유니티에는 컴파일러가 없고 인터프리터가 있음
ㄴ 컴파일러가 없기 때문에 pragma가 없음

언리얼에는 컴파일러와 인터프리터가 있음
ㄴ 인터프리터가 있기 때문에 인터프리터롤 고려해서 pragma가 없음


▶ 매크로 상수를 정의할 때 주의점

1. #define문은 코드를 생성하는 명령이 아니며 매크로의 이름도 일종의 명칭이기 때문에
명칭 규칙에 맞게 작성해야 한다.

2. 매크로 이름에는 공백이 들어갈 수 없지만 매크로 실제 값은 공백을 가질 수 있다.
	 #pragma MESSAGE "똑바로 합시다."

3. 문자열 상수 내에 있는 매크로나 다른 명칭의 일부로 포함된 경우는 치환되지 않는다.
	ㄴ #define NUM 5   ->  NUM을 찾아 5로 치환

4. 매크로는 중첩이 가능
	ㄴ #define A 3
	ㄴ #ddfine B (A * 3)

5. 값을 가지지 않는 빈 매크로도 정의 가능
	ㄴ #define AAA  => 값 자체가 없기 때문에 매크로 상수 자체만 존재할 뿐이다.

6. 매크로 상수는 단순히 컴파일 전에 코드를 튜닝하는 전처리기에 의해서 처리되는 상수이기 때문에
컴파일러 입장에서는 리터럴 상수와 동일 시 된다.
	ㄴ 컴파일러는 매크로 상수의 존재를 알지 못한다.

#define 자리에 const가 들어갈 수 있고 const자리에 #define이 들어갈 수 있다. 아무런 문제가 없음.
*/
#pragma endregion

//#pragma message("Example_05_C.cpp 수정 금지")

// 매크로 정의: #define 매크로명 실제값
// ㄴ 매크로에 표기법은 대문자 + 스네이크
#define EXAMPLE_1 1
#define EXAMPLE_2 1

#undef EXAMPLE_2 // 매크로가 해제된다
#define EXAMPLE_2 2

// C언어 스타일
#define TRUE 1
#define FALSE 0

#define ADD(a) ((a) * (a)) // 매크로는 상수처럼 쓸 수 있고, 함수처럼도 쓸 수 있다, 단. 복잡한 연산이 있는 함수는 불가능

void GetMultipleValue(int numA);

void main()
{
	cout << ADD(5) << endl;
	GetMultipleValue(5);

#ifdef EXAMPLE_1
	cout << "1번 예시 출력" << endl;
#endif // End Of EXAMPLE_1

#if(EXAMPLE_2 == 1)
	cout << "2번 예시 출력" << endl;
#elif EXAMPLE_3 
	cout << "3번 예시 출력" << endl;
#elif(EXAMPLE_2 == 2)
	cout << "4번 예시 출력" << endl;
#endif// End Of EXAMPLE_1


}


void GetMultipleValue(int numA)
{
	cout << numA * numA << endl;
}


/*

과제1. 가위바위보

- 스위치문을 이용해 만든다.(베이스가 switch여야 한다)

- 치트 기능과 배팅 기능 추가
ㄴ 초기 소지금: 10,000원
ㄴ 최소 배팅: 1,000원

- 5판을 하거나 내가 가진 돈을 전부 잃으면 게임 종료

- 이기면 판돈에 x3배를 얻고 지면 판돈에 x7배를 잃는다.

- 비길 경우 판돈에 x5배를 얻는다.


or
과제2. 숫자 야구

- 0 ~ 9까지의 숫자 중 컴퓨터가 임의로 3개를 뽑는다.

- 컴퓨터가 뽑은 숫자를 플레이어가 임의의 숫자 3개를 선택하여 숫자와 자리수까지 맞히는 게임
	ㄴ 1. 선택한 숫자가 컴퓨터 숫자와 같으나 자리수가 다를 경우: 123볼
	ㄴ 2. 선택한 숫자가 컴퓨터 숫자와 같고 자리수까지 같을 경우: 1 스트라이크
	ㄴ 3. 해당하는 숫자가 없을 경우: 1아웃

- 이렇게 한 턴에 3스트라이크를 만들 경우 몇 번만에 맞혔는지 결과를 보여주며 게임을 끝낸다.

- 필수: 치트
ㄴ 배열 x

타임 어택. 가위바위보(if)

-주어진 시간 안에 가위바위보 로직을 작성 후 실행하여 정상 동작되면 OK
ㄴ 반에서 3명 이상 실패시 매 과제마다 타임어택이 추가될 것이니 열심히 해온다.
ㄴ 성공을 못한 인원은 3 X 못한 인원수 = 깜지
10분 안에 완성할 것


한 줄 조사. 배열 + 포인터(

- 노트에 적어올 것.

- 비유할 것 생각해 온다.



*/
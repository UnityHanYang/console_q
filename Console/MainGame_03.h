#pragma once
#include "Player_03.h"
#include "Poison_01.h"

// 둘의 차이점: 오류 발견 시기가 컴파일 타임이냐 런타임이냐
#include <assert.h>
//C는 컴파일에 가기전에 잡아준다(런타임)

#include <cassert>
//C++은 컴파일 타임에서 잡아준다

#pragma region 예외처리
/*
▶ 예외처리 (Exception, Handling)

- 프로그램 동작 도중 발생하는 의도하지 않는 상황을 처리하는 기법 혹은 방법이라고 할 수 있다.

- 예외처리를 위해 여러가지 방법을 동원할 수는 있지만 기본적으로 조건문을 통한 예외처리가
일반적이긴 하다. (우리에게 익숙한 바로 그 if ~ else문)

- 하지만 if문을 보고 예외처리를 위한 코드인지 프로그램의 흐름을 제어하는 코드인지
구분하기가 쉽지가 않고 무엇보다 퍼포먼스 이슈가 생길 여지가 다분하다.


 대표적인 예외처리 방법

1. 조건문을 통한 예외처리

- 프로그램이 중단될 수 있을만한 처리를 조건문을 통해 진행할 수 없도록 제한하는 기법
ㄴ 차선책 => 가장 좋은 예외처리 방법은 처음부터 예외가 발생할 수 없도록 설계하는 것
				ㄴ C/C++은 제외 -> 메모리 접근을 할 때는 유효성 검사를 해야하기 때문
			ㄴ 메모리 접근 한에서는 다른 문법보다 굉장히 유효하다


2. try catch throw 예외처리

- C++은 구조적으로 예외를 처리할 수 있는 메커니즘을 제공한다.
	ㄴ 이러한 try catch throw 구문은 구조적으로 예외를 처리할 수 있는 문법

- 장점이라고 한다면 예외의 처리를 프로그램의 일반적인 흐름에서 독립시키는 것이 가능
ㄴ 이는 가독성과 유지보수성을 높일 수 있을 뿐만 아니라 협업시에도 유리한 경우가 아주 많다.

EX)
- try: 예외발생에 대한 검사의 범위를 지정하는 블록
- catch: 발생한 예외를 처리하는 블록
- throw: 발생한 예외에 대한 정보를 전달하는 구문


3. 스택 풀기

- 스택 풀기는 함수에서 예외적으로 오류가 발생했을 때 catch문들을 발견할 때까지 호출된 함수들은
풀어내야 


4. Exception 클래스 활용

- C++에서 여러 예외를 처리하기 위해 제공하는 클래스

- Exception 클래스는 예외 메시지를 생성하여 전달 하기가 가능하다.
ㄴ 이는 다른 파트에서 예외를 전달받아 처리한다는 것을 의미한다.


★ 중요 ★
5. assert

- 프로그램에서 치명적일 수 있는 문제에서 프로그램을 중단하고 오류를 표시하며 프로그램 터뜨리기

- 프로그램을 중단시키고 오류를 표시하기 때문에 개발자의 디버깅에 유리한 면이 있다.

- 또한 assert는 false인 경우 오류를 처리하며 && 후 메시지를 입력하여 확인하는 것이
일반적인 처리 방법


 

- 디버깅 모드에서 동작하는 오류 검출용 함수라고 할 수 있다.
ㄴ 릴리즈에서는 동작을 하지 않는다.

- assert에 걸리게 되면 버그의 발생 위치나 call stack등 여러 정보를 확인할 수 있기 때문에
오류 수정에 용이할 때도 있다. (Expression -> false -> assert error)

※ 그리고 주의할 점은 대부분의 문법이 true를 기준으로 동작하지만 assert 같은 경우 거짓일 때
동작을 한다. 이는 일어나면 안 되는 조건이 아니라 꼭 일어나야 하는 조건을 명시해야 한다.

EX) assert(A != NULL);
ㄴ A가 NULL이 아니면 true가 나오게 되므로 패스
ㄴ A가 NULL이 맞다면 false가 나오게 되므로 assert error

--
HRESULT hr;
hr = RegisterClass(&wndClass);
assert(SUCCEEDED(hr));

--
_start = new startScene;
_start->init();

_currentScene = _start;

assert(_currentScene != nullptr);


assert(): [C] -> 컴파일 타임을 지나 프로그램을 실행시키고 문제를 파악 (런타임)
static_assert(): [C++] -> 컴파일 중에 문제 파악 (컴파일 타임) (컴파일 타임이기 때문에 상수만)


※ assert의 설계 방법, 어떻게 쓰는지 공부할 것
면접 문제 준비
*/
#pragma endregion


class MainGame_03
{
private:
	// 둘의 차이점
	//Player_03 _Player; // 사용자가 어떤 변수를 쓸지 몰라서 맴버변수를 전부다 세팅을 해야함(맴버변수 크기의 총합)
	// 정적 할당-> 런타임에서 값을 수정할 수 없음.
	// 미리 맴버 변수들을 준비했기 때문에 바로바로 쓸 수 있어서 속도가 빠름.

	Player_03* _Player;
	// 맴버변수의 크기가 어떻게 되든, 4~8바이트만 쓴다.
	// 정적 할당 보다 속도는 느리지만 포인터가 효율적이다.

	Poison_01* _Poison;

public:
	MainGame_03();
	~MainGame_03();
};


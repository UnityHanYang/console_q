#pragma once
#include <iostream>
#include <Windows.h>

using namespace std;

#pragma region 가상함수
/*
▶ 가상 함수란?

- 부모 클래스의 특정 함수가 자식 클래스에 재정의 되었을 경우 부모 클래스의 참조 또는 포인터를 가지고
자식 클래스의 특정 함수를 실행시키는 매커니즘을 의미한다.

- 이를 잘 활용하면 객체의 계층 구조에 따라 자식 클래스의 특정 함수를 호출하는 것이 가능하다.

▷ 가상 함수의 특징

- C++ 클래스의 특성 중 하나인 다형성을 지원하기 위해 "virtual" 키워드를 사용한다.

- 부모 클래스 내에서 virtual로 선언된 함수는 자식 클래스에서 재정의 될 수 있다.
ㄴ 이를 오버라이딩이라고 한다.

- 재정의 되지 않는다면 호출시 부모 클래스의 함수가 호출되고 재정의 되었다면 함수 호출시 자식 클래스의
함수가 호출된다.

 다형성?

- 여러가지를 표현할 수 있다는 뜻

- 자식 객체의 인스턴스를 부모 객체의 타입으로 간접 지정이 가능하다는 얘기
ㄴ 클래스 캐스팅(업 캐스팅)
ㄴ 부모 객체를 자식 객체로 던져주면 다운 캐스팅

 인스턴스

- 어느 클래스에 속하는 각 객체를 인스턴스라고 할 수 있다.

EX) 집이라는 클래스를 만들고 내 방이라는 객체를 생성하면 그 클래스의 인스턴스

▷ 함수 오버로딩 VS 함수 오버라이딩

- 할당하는 메모리 영역의 차이가 존재
ㄴ 함수 오버로딩은 일반적으로 스택에 들어간다.
ㄴ 함수 오버라이딩은 일반적으로 힙에 들어간다.

- 바인딩(결합) 차이가 존재
ㄴ 함수 오버로딩은 정적 바인딩
ㄴ 함수 오버라이딩은 정적+동적 바인딩(네임맹글링)
									ㄴ 이름을 만들어 주는데, 실시간 컴파일을 해서 네임맹글링
*/
#pragma endregion

#pragma region 객체지향
/*

▶ 객체지향 (OOP: Object Oriented Programming)

- 코드의 재사용성이 높고 코드의 관리가 용이하다.

- 이는 곧 신뢰성이 높은 프로그래밍을 가능하게 한다.
	ㄴ 어떻게든 수단과 방법을 가리지 말고 구현을 먼저 할 것


▶ 객체지향 4대 요소 (특징)

캡슐화

- 객체의 속성을 보호하기 위해 사용한다.


상속

- 객체지향에서의 상속은 하위로 내려갈수록 구체화 되는 것을 의미한다.

- 잘 짜여진 상속 구조는 프로그램 구조에 대한 이해도를 상승 시킨다.
	ㄴ 클래스가 아무리 많다고 하더라도 최상위 클래스의 구조를 보면 하위 클래스의 동작 방식을 유추할 수 있다.

- 재사용성 향상
	ㄴ 이는 상속을 이용하여 해당 클래스에 필요한 속성 및 함수를 모두 정의하지 않고 상속을 받아서 사용할 수 있다.

- 확장성 향상
	ㄴ 일관된 형태의 객체를 추가할 수 있으므로 간단하게 프로그램 확장이 가능하다.

- 유지보수성 향상
	ㄴ 각 객체마다 일관된 형태를 지니고 있기 때문에 유지보수에 유리하다.


객체지향의 단점에서 상속이 포함된다.

- 유연한 코드 작성 불가


다형성

- 하나의 개체가 여러 형태로 변화하는 것을 의미한다.
	ㄴ overriding

	설계방식, 최신 트랜드 방식

추상화

- 공통적인 부분과 특정 특성을 분리 및 추출해 재조합 및 재구성
	ㄴ 기본적으로 추상화는 다형성 + 상속을 모두 포함할 수 있다. -> 다형성, 상속 보다 상위 객체라는 뜻

- 클래스를 정의할 당시 구체화 시킬 수 없는 기능을 추상적 표현으로 정의한다.



 객체지향 4대 특징 요약

 캡슐화
 ㄴ 객체를 상태와 기능으로 묶는 것을 의미한다.
 ㄴ 객체의 내부 상태와 기능을 숨기고 허용한 상태와 기능만의 엑세스 허용

 상속
 ㄴ 부모 클래스의 모든 기능을 가지는 자식 클래스를 설계하는 기법

 다형성
 ㄴ 부모 클래스의 함수를 자식 클래스에서 재정의하여 자식 클래스의 다른 반응을 표한허거나 구현하는 것을 의미한다.

 추상화
 ㄴ 관련 특성 및 앤티티의 상호작용을 클래스로 모델링하여 시스템의 추상적 표현을 정의한다.


 ▶ 객체지향 5대 설계 원칙 (SOLID)

 1. SRP (단일 책임의 원칙)

 - 결합도를 낮추고 응집도를 높여라.

  결합도
	ㄴ 모듈간의 상호 의존 정도를 나타내는 지표
	ㄴ 결합도가 높은 코드는 일단 답이 없다... -> 롤백으로 하나하나 지우는 방법 밖에 없다.
	ㄴ 결합도가 낮으면 상호 의존성이 줄어서 재사용 및 유지보수에 유리하다.

  용집도
	ㄴ 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성을 의미한다.
	ㄴ 용집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아지므로 재사용 및 유지보수에 유리하다.

※ 유효타가 있는 상속 / 오버라이딩을 사용할 것


 ※ 디자인 패턴


 2. OCP (개방 폐쇄의 원칙)

 - 자신의 확장에는 열려있고 주변의 변화에 대해서는 닫혀 있어야한다.

 - 상위 클래스 또는 인터페이스를 중간에 두어 자신의 변화에 대해서는 폐쇄하고 인터페이스는 외부 변화에 대해
 확장성을 개발한다.


 3. LSP (리스코프 치환의 원칙)

 - 하위 타입은 언제나 자신의 기반인 상위 타입으로 교체할 수 있어야 한다.

 EX) 상위: 자동차 / 운송수단 -> 하위: 아반떼, 그랜져

 ※ 설계 원칙을 만들 때 들어가는 개념


 4. ISP (인터페이스 분리의 원칙)

 - 클라이언트는 기본적으로 자신이 사용하지 않는 함수에 의존 관계를 맺으면 안 된다.

 - 인터페이스로 각 기능을 분리하여 사용하는 함수에만 의존 관계를 맺는다.

 - 프로젝트 요구사항과 설계에 따라서 SRP / ISP 중에 1개를 선택한다.
 

 5. DIP (의존관계 역전의 원칙)

 - 자신보다 변하기 쉬운 것에 의존하지 말아야 한다.

 - 이는 개방 폐쇄 원칙에서 살펴본 내용과 동일


  객체지향 5대 설계 원칙 요약

(S) 단일 책임 원칙
ㄴ 객체는 오직 하나의 책임을 가져야 한다.

(O) 개방 폐쇄 원칙
ㄴ 객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다.

(L) 리스코프 치환 원칙
ㄴ 자식 클래스는 언제나 자신의 부모 클래스를 대채할 수 있어어 한다.

(I) 인터페이스 분리 원칙
ㄴ 인터페이스는 작은 단위들로 분리시켜 구성하며 사용하지 않는 함수들은 포함하지 않아야 한다.

(D) 의존성 역전 원칙
ㄴ 객체는 하위 클래스보다 상위 클래스에 의존해야 한다.


*/
#pragma endregion

#pragma region 순수 가상함수 + 추상 클래스 + 인터페이스
/*
인터페이스 == 순수 가상 함수

▶ 순수 가상 함수 (Pure virtual Function)

- 함수의 구현부가 없고 선언부가 = 0 으로 끝나는 가상 함수를 뜻한다.


- Declare  Example

virtual void IFunctionA() = 0;
virtual void IFunctionB() = NULL;
virtual void IFunctionC() PURE;
virtual void IFunctionD() abstract;

※ 특정으로는 부모 클래스에서 순수 가상 함수를 선언하면 자식 클래스에서는 반드시 재정의한 함수를 맴버로 가져와야 한다.

▶ 추상 클래스

- 순수 가상 함수가 1개 이상 있는 클래스를 뜻한다.
	ㄴ 하나 이상의 순수 가상 함수를 포함하는 클래스라고 생각하면 된다.

- 클래스가 추상적인 표현을 정의하는 경우 자식에서 구체화 시켜 구현할 것을 염두하고 추상화 시킴

- 추상 클래스에서 내용을 구체화 할 수 없는 순수 가상 함수는 내용을 정의하지 않는다.

- 추상 클래스를 상속하는 자식 클래스가 순수 가상 함수를 재정의하여 구체화한 경우 사용이 가능


 특징

 1. 객체를 생성할 수 없다.

 2. 단, 포인터 변수는 만들 수 있다.

 3. 또한 추상 클래스로 지정한 객체는 인스턴스를 만들 수 없다.

 4. 다만 추상 클래스의 자식 클래스를 통해 인스턴스를 생성할 수 있다.

 5. C++ 같은 경우에는 새롭게 추가된 abstract 키워드를 통해 명시가 가능
 
 6. 맴버 변수 또는 일반 맴벼 함수가 포함된 여부와 상관없이 순수 가상 함수를 1개 이상 가지고 있는 클래스는 추상
 클래스가 될 수 있다.

 
 EX)
 class IWindowMessageHandler abstract
 {

 };

 abstruct class ITessellation
 {

 };

 ▶ 인터페이스

 - OCP

 - 순수 가상 함수로만 이루어진 클래스를 인터페이스라고 한다.

 - 인터페이스의 개념은 하위 클래스에서 반드시 정의해야 할 함수를 정해주는 클래스라고 할 수 있다.

 - C++은 인터페이스라는 개념을 공식적으로 기능으로는 지원하지 않는다.

 - 표기법: 파스칼 + 헝가리안

 
 ※ 인터페이스 (순수 가상 함수 설계) -> (상속) 추상 클래스 (기본 기능 구현) -> (상속) 기본 클래스 (재정의)


 특징

- 맴버 변수 및 함수를 포함할 수 없다. (정적 포함)

- 한정자 사용 금지(자기 속성을 바꿔주는 키워드 - > const, static_cast)

- 기본 클래스를 상속받을 수 없다.

- 순수 가상 함수만 포함 시켜야 한다.

- 생 / 소 / 연(연산자 오퍼레이터 포함) 포함할 수 없다.

- public 속성을 가지고 있어야 한다.


▷ 장 / 단점

1. 상속 (다중)에서의 안정성이 증가한다.

- C++은 다중 상속을 지원하는 언어지만 설계를 고려하지 않는다면 기능이 중첩되는 중첩화 현상이 비일비채가 발생한다.
ㄴ 이는 다이아몬드 상속 구조의 가장 큰 문제점인데 인터페이스는 이러한 중첩화 현상을 없애는데 탁월하다.
ㄴ 인터페이스 자체가 맴버 변수 또는 맴버 함수가 겹칠 일이 없기 때문에 다중 상속의 단점을 상쇄한다.

2. 재사용성 / 재생산성이 아주 좋다.

- 기반이 되는 클래스를 1개 만들고 그 클래스에 기반하여 자식들을 정의할 것이기 때문에
ㄴ 구심정이 있다는 얘기

3. 추상화를 기반으로 삼아 구현되기 때문에 가독성이 떨어지고 코드 흐름을 파악하기가 어렵다.

4. C++에는 사용할 수 있는 키워드가 없으므로 프로그래머가 의한 실수가 발생할 여지가 다분하다.
	ㄴ 정확히는 강제성이 없다.



★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
▶ 가상 소멸자 -> 일단 붙여


- 인터페이스나 추상 클래스 / 혹은 가상 함수에서 동적 할당된 부모 클래스를 메모리 해제하면 자식 클래스의 소멸자를 호출해야 하는데 부모 클래스의
소멸자만 들어온다.

- 이러한 호출 순서에 의한 문제를 해결하기 위해 소멸자에도 virtual 키워드를 추가해 가상 소멸자로 만들어 줘야 자식 클래스의 
소멸자를 호출할 수 있다.

※ 가상 소멸자는 상속 관계에서 잠재적인 오류에 대한 문제점을 해결할 수 있다.
ㄴ 여기에는 메모리 관리 문제도 포함이 된다.

※ 성능저하 이슈가 생길 여지가 있기 때문에 상속 관계가 아니라면 사용을 자제해야 한다.
속도 이슈가 생긴다
ㄴ 정적 / 동적바인딩으로 인한 퍼포먼스 이슈가 있다

*/
#pragma endregion


class MainGame
{
public:
	virtual void IFunctionA() = 0;
	virtual void IFunctionB() = 0;
	virtual void IFunctionC() PURE;

	// 생 / 소 => 생략
};


__interface IGameClass // 언더바 2개는 명시 키워드
{
	// 컴파일에서 인터페이스처럼 사용을 안 해도 오류를 띄우지 않는다 -> 프로그래머가 실수하면 답이 없다.
	virtual void idle() PURE; // 메모리를 해제할 수 없다, 상속을 전제로 만들어진다.
	virtual void attack() PURE; // 이 친구들이 나오면 무조건 가상 소멸자를 사용해야 한다.
};

class CharacterChoices abstract : public IGameClass
{
private:

public:
	CharacterChoices();
	~CharacterChoices();
};


class Warrior :public CharacterChoices
{

};

class Wizard : public CharacterChoices
{

};


// 부모
// 부모 클래스는 웬만하면 virtual 키워드를 가지고 있어야 한다.
class weapon
{
public:
	virtual void attack() { cout << "무기로 공격한다." << endl; }
};

// 자식
class gun : public weapon 
{
public:
	void attack() { cout << "총으로 공격" << endl; }
};

class bow : public weapon
{
public:
	void attack() { cout << "활로 공격" << endl; }
};

class MainGame_05
{
private:
	weapon* _gun;
	weapon* _bow;
	weapon* _myWeapon;


public:
	MainGame_05();
	~MainGame_05();
};

/*

과제1. 빙고 만들기

A.
- 0 ~ 24까지의 수를 랜덤으로 배치해서 5 X 5로 출력

- 숫자를 선택하면 #, %, & 등으로 바꾼다.

- 빙고가 되면 빙고 카운트가 올라가고 5빙고가 되면 게임이 종료된다.
ㄴ 게임이 종료되면 프로그램이 종료되는게 아닌 완성된 빙고 화면을 계속 보여줘야 한다.
ㄴ 이 화면에서 내가 게임 종료라는 선택지를 고르면 프로그램은 종료된다.

B.
- 위와 룰은 동일하다.

- 단, 혼자하는 빙고가 아닌 AI와 번갈아 가며 플레이 하는 빙고를 만들어 온다.

[작업 지시서]

- 제시된 문서의 내용을 보고 답안을 작성 후 제출하시오.

1. 선다형의 답을 정하고 왜 답으로 선정했는지 본인의 의견을 기술할 것

2. 서술형의 내용을 기입할 것

3. 문제 풀이중 참고를 했다면 반드시 표기할 것

- 아래 메일로 "양식"을 꼭 지켜서 보낸다.
ㄴ VR 7기_프로그래밍 언어 활용_이름


첨부 파일명:
VR 7기_프로그래밍 언어 활용_이름.zip




중간 과제 점검

- 아래 메일로 "양식"을 꼭 지켜서 보낸다.

메일 주소:
ㄴ star_marker@naver.com

메일 제목:
ㄴ VR 7기_콘솔 중간 과제 제출_이름

첨부 파일명:
VR 7기_콘솔 중간 과제 제출_이름.zip

메일 내용:
ㄴ 특이사항 기입


작업지시서, 중간과제 정검 둘다 이번 주 목요일 수업시간 전까지 보낸다.
*/


#pragma once
#include <iostream>
#include <vector>

using namespace std;

#pragma region 알고리즘 + 자료구조
/*
STL = 자료구조, 알고리즘

▶ 알고리즘

- 문제를 해결하기 위해 정해진 진행절차나 방법을 의미한다.
ㄴ 컴퓨터에서 알고리즘은 어떠한 행동을 하기 위해

 알고리즘 조건

1. 입력
ㄴ 알고리즘은 0개 이상 입력을 가져야 한다.

2. 출력
ㄴ 알고리즘은 최소 1개 이상의 결과를 가져야 한다.

3. 명확성
ㄴ 수행 과정은 모호하지 않고 정확한 수단을 제공해야 한다.

4. 유한성
ㄴ 수행 과정은 무한하지 않고 유한한 작업 이후에 정지해야 한다.

5. 효과성
ㄴ 모든 과정은 명백하게 실행이 가능해야 한다.


 알고리즘 성능

- 효율적인 문제해결을 위해선 알고리즘의 선능 판달할 수 있는 기준이 필요하다.
ㄴ 이는 상황에 따라 적합한 알고리즘을 선택할 수 있도록 기준을 제시할 수 있다는 것을 의미한다.

※ 평가 기준

- 컴퓨터에서 알고리즘과 자료구조의 평가는 시간과 공간, 두 자원을 얼마나 소모하는 지가 효율성의 중점
	ㄴ 일반적으로 시간을 위해 공간이 희생되는 경우가 많다.
		ㄴ 공간 복잡도
		ㄴ 시간 복잡도


  Big-O 표기법

- 알고리즘의 복잡도를 나타내는 정근표기법
	ㄴ 이를 활용해 데이터 증가량에 따라 시간 증가량을 계산한다.

- 기본적으로 가장 높은 차수와 나머지 모든 항을 제거하고 표시한다.

- 알고리즘이 효율적인지 대략적인지 파악을 할 수 있는 수단



▶ 자료구조

- 프로그램에서 데이터를 효율적인 접근 및 수정을 가능케 하는 자료의 조직 / 관리 / 저장을 의미한다.

- 데이터 값의 모임, 또 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수나 명령을 의미


  자료구조 형태

-선형구조
ㄴ 자료간 관계가 1 : 1 구조
	ㄴ EX) 배열, 연결 리스트, 스택, 큐, 덱

-비선형구조
ㄴ 자료간 관계가 1 : 다 or 다 : 다 인 구조
	ㄴ 트리 / 그래프(random이 그래프로 이루어져 있음)


*/
#pragma endregion

// O(1)
int Case_1(int n)
{
	int sum = 0;
	sum = n * n;

	return sum;
}

// O(n)
int Case_2(int n)
{
	int sum = 0;

	for (int i = 0; i < n; i++)
	{
		sum += n;
	}
	
	return sum;
}

// O(n^2)
int Case_3(int n)
{
	int sum = 0;

	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			sum++;
		}
	}
	return sum;

	//시간복잡도 잡아먹는 순위 -> 반복문 -> 연산자
	// 반복문 안에 있는 조건문이 제일 워스트
	// 조건문, 반복문, boolean
}

int FindIndex(int array[], int start, int end, int value)
{
	for (int i = start; i <= end; i++)
	{
		if (array[i] == value)
		{
			return i;
		}
	}
	return -1;
}

/*                          ┌─────────────┐
입력 값        Case 1        │    Case 2   │        Case3
1                1          │     1       │          1
10               1          │     10      │          100
100              1          │     100     │        10,000
1000             1          │     1000    │       1,000,000
n               O(1)        │     O(n)    │         O(n^2)
Big-O           최선        │     평균     │         최악
                            └─────────────┘
						평균으로 알고리즘을 짜야한다
  */

#pragma region STL 백터 + 이터레이터
/*
* 
▶ 백터란?

- STL에 속해 있는 컬랙션 클래스 중 하나로써 배열처럼 동작하는 컬렉션 클래스를 의미한다.

- 일반적인 배열에 비해 데이터를 추가하기 위한 개수가 제한되어 있지 않기 때문에 컴퓨터가 허락하는 한
많은 양의 데이터를 추가하는 것이 가능하다.

- STL 백터는 시퀀스 기반이다.
ㄴ 별다른 규칙이나 제약이 존재하지 않는 일반적인 컨테이너

- 시퀀스 컨테이너는 데이터를 선형으로 저장하며 시퀀스 컨테이너는 삽입 된 요소의 순서가 그래도 유지된다는 특징이 있다.



 시퀀스 컨테이너

- 기본적인 컨테이너에 몇가지 규칙을 만족한다면 시퀀스 컨테이너가 된다.
	ㄴ 대표적으로 vector, list, deque 등이 있다.
				 ㄴ C#에선 vector가 array list로 바뀜

1. 모든 요소는 직선 순서대로 배치되어야 한다.
ㄴ 이 얘기는 첫 번째 요소와 마지막 요소를 제외한 나머지 요소들은 반드시 앞 뒤로 인접한 요소를 하나씩 가지고 있어야 한다.

2. 최소한 순방향 반복자를 가지고 있어야 한다. (Forward)
ㄴ 이는 반복자가 이동할 때마다 요소들의 순서가 변하지 않음을 보장해 주는 것

3. 시퀀스 컨테이너의 요소들은 명확한 순서를 가진다.
ㄴ 그러므로 특정 위치를 참조하는 연산이 가능해야 한다.


▷ 백터의 특징

- 시퀀스 기반

- 배열 기반 컨테이너

- C++에서 활용 빈도가 높고 사용하기가 쉽다.
	ㄴ 이는 C#의 List = foreach 콤보로 이어진다.

- 검색 속도가 빠르다.
ㄴ 읽기 능력이 탁월하다.

- 대신 입출력은 느리다.
ㄴ 삽입 삭제 때문에

백터는 빈 공간을 없애기 위해 계속 매워주는 특성을 지니고 있다.

백터의 단점을 보완한게 list -> 산입, 삭제가 백터보다 빠르다.

백터 형태에 클래스를 참조하는 형태가 가장 효율적이다
 ㄴ 클래스와 포인터가 들어간다는 뜻

- 대표적 특징으로는 새로운 메모리를 할당해 새로 추가한 원소와 함께 복사한다.

- 메모리 소모량이 크다.
(포폴할 땐 vector를 많이 내려놔야한다)


2024.04.12
▶ 이터레이터란?

스마트 포인터(해제는 알아서 한다)
ㄴ참조카운트를 가지고 있다.
- 스마트 포인터로 구현되어 있는 대표적인 컬렉션 클래스

- 컬렉션 클래스에 보관되어 있는 각 데이터에 접근하기 위한 포인터 객체로써 STL에 포함되어 있는 모든 컬렉션 클래스는
데이터 시작과 끝을 나타내는 Begin() + end() 함수를 지니고 있기 때문에 이터레이터를 사용할 수 있다.

- 따라서 begin()부터 시작해서 end()까지 루프를 반복하게 되면 컬렉션에 포함되어 있는 모든 데이터에 접근하는 것이 가능하다.

- 자료구조에 저장되어 있는 요소들을 반복하고 개별 요소에 대해 접근을 제공하는 객체라고 생각하면 편하다.
ㄴ C++의 모든 자료구조는 반복자를 제공하고 있다.

- 또한 C++의 알고리즘은 반복자를 통해 구현하기 때문에 자료구조 종류와 무관하게 동작이 가능하다.

순차 리스트 (선형)
ㄴ 인덱스 하나씩 증가시켜서 실행

연결 리스트 (비선형)

*/
#pragma endregion


#pragma region 순차리스트
/*

*/
#pragma endregion


struct STData
{
	int m_nValue;
	std::string m_oString;
};

class MainGame_06
{
private:
	// 1.
	//vector<MainGame_06*> vec; // 백터를 썼을 때 가장 이상적인 방법 -> 클래스를 참조형식으로 쓰는 것
	
	// 정수형 백터 선언
	std::vector<int> _vNumber;
	// 정수형 백터 반복자 선언
	std::vector<int>::iterator _viNumber;
	std::vector<int>::reverse_iterator _vriNumber;

public:
	STData* sd;
	void PrintVector();
	inline void LinePrint() { cout << "==================================" << endl; }

	// 2.
	void SampleVector(std::vector<int> valueList);
	void SampleSTVector(std::vector<STData> valueList);
	void PracticeVector(void);


	MainGame_06();
	~MainGame_06();
};

/*
과제1. 숫자 슬라이드

- 사이즈
ㄴ 1. 5 X 4
ㄴ 2. 시작할 때 가로 + 세로를 입력하는 버전

- 필수
ㄴ 1. 게임 룰에 기반한 일반적 예외처리를 해온다.
	ㄴ Ex: 벽 밖으로 못 나가게 하기 등등..
ㄴ 2. 치트
	ㄴ 치트키를 누르면 하나의 숫자를 제외하고 나머지 숫자는 정렬
	ㄴ 사용자가 마지막 조각을 맞추면서 프로그램이 끝나면 OK
ㄴ 3. 몇번만에 맞혔는지 카운트 할 것

- 숫자가 이동할 때 애니메이션 효과를 구현해 오면 Good
*/

/*
과제1. 함수와 백터의 만남

- 수업 시간에 작성된 샘플 함수를 효율성 있고 재생산성 있게 구현해 오도록

- 함수 원형은 건들지 않는다.

- 추상화


과제2. 대전 게임 만들기

- 클래스는 6개 이상

- 스타트씬과 게임 씬으로 구성

- 도트와 색상 + HP바 필수
ㄴ 도트는 본인에 포트폴리오 도트를 사용해도 무방

- 자동 전투가 아닌 한 턴씩 치고받게 구현해 올 것
ㄴ 플레이어: 스킬 2개 / 적: 스킬 2개
ㄴ 공격, 스킬, 방어 등을 입력 받을 수 있게


- 게임 오버 조건 만들어 올 것

- 기본 베이스는 좌우 대칭으로 구성한다.
*/


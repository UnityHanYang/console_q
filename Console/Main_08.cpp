#include <iostream>

using namespace std;

#pragma region 포인터 + 스마트 포인터
/*
▶ 포인터(원시 포인터)

- 값을 저장하는게 아닌 어떤 값의 주소를 저장하는 개념

- 메모리 주소를 의미하며 포인터를 통해서 데이터에 간접적으로 접근하는 것이 가능하다.
ㄴ 포인터를 활용하면 다른 영역에 있는 변수라고 할지라도 값을 변경하는 것이 가능하다.

 포인터의 핵심

- 포인터: 가르키는 놈 / 주소를 담는 놈

- 어떠한 값의 주소 -> 해당 값이 저장된 컴퓨터 메모리상의 주소를 의미한다.

- *: 해당 메모리에 있는 데이터 값을 가져오는 역할을 한다.

- &: 주소값을 반환하는 연산자

- ->: 객체 맴버에 접근할 때 사용이 된다.

※ 포인터는 좋은 문법인건 맞지만 메모리 상의 어떤 위치든 접근하는 것은 불가능
ㄴ 컴퓨터는 변수의 할당을 통해서 메모리의 사용 권한이 주어진 위치만 포인터를 통해서 
접근 하는 것을 허용한다.

▷ 포인터에 자료형이 필요한 이유

- 포인터는 단순히 메모리의 주소에 불가하다.
ㄴ 그렇기 대문에 해당 정보만을 가지고는 메모리의 크기를 정확하게 알 수 없다.
ㄴ 포인터와 자료형을 통해서 저장 및 읽어 들일 메모리의 크기를 기본적으로 명시해야 한다.
	ㄴ 포인터와 해당 포인터에 저장할 변수의 자료형은 반드시 일치해야 한다.
	데이터가 얼마나 들어가든(int변수를 4000개 사용하면 4000byte) 4바이트나 8바이트로 쓸 수 있다

- void*: 메모리의 주소만을 보관하고 싶을 때 사용한다. (특정 자료형을 명시 x)
ㄴ 해당 형태를 보이드 포인터라고 부르며 보이드 포인터는 어떠한 자료형의 메모리 주소도 보관하는 것이
가능하다.

- 또한 포인터는 메모리의 주소를 보관하는 역할을 하기 때문에 포인터의 크기는 모두 동일하다.
ㄴ 운영체재 및 개발 환경에 따라 크기가 유동적이긴 하지만 자료형에서는 모두 동일하다.
ㄴ int* / float* / double* / char* => 동일


 함수의 종류

- Call By Value
- 값 전달 (값에 의한 호출 -> 호출 된 함수의 매개변수로 복사가 이뤄진다.)
ㄴ Ex) int AddValue(int a, int b);

-Call By Reference
ㄴ 주소 값 전달 (참조)
ㄴ EX) int AddValue(int* a, int* b);

▶ 스마트 포인터

*/
#pragma endregion

/*

과제1. 수업 시간에 진행된 출력 부분 고민해보기

- 어떤 값이 들어갈지 생각해 보고 왜 그렇게 생각했는지 주석으로 기입해서 기록해 둘 것

과제2. 간단한 복습 과제

- 두 정수 사이의 합을 구하는 프로그램을 만들어 올 것
ㄴ 두개의 숫자를 사용자를 통해 입력 받는다.
ㄴ 입력한 두 숫자의 사이의 합을 출력하면 OK
	ㄴ 예외처리: 5번과 1번을 누른다 -> 재입력 처리
ㄴ 또한 숫자의 합이 100 이상이면 프로그램은 종료된다.
ㄴ EX) 1과 5를 입력 => 결과값: 9
	ㄴ 큰 숫자가 앞에 올 수 없다.
	EX) 5와 1은 안 됨
	ㄴ 음수는 제외


- 타임 어택 과제 - 10분
과제3. 월남뽕

- 치트 필수

♠ 1 ~ 13까지의 카드
◆ 1 ~ 13까지의 카드
♣ 1 ~ 13까지의 카드
♥ 1 ~ 13까지의 카드

- 종류별 13장의 카드 => 총 52장의 카드를 사용한다.

예외처리:
ㄴ A = 1
ㄴ J = 11
ㄴ Q = 12	
ㄴ K = 13

- 52장의 카드를 최소 한번 랜덤으로 섞고 그 후 매턴 마다 3장씩 뒤집는다.


- 얖쪽에 배치된 두 장의 카드를 보고 최소 배팅액 이상의 금액을 배팅
ㄴ 최소 배팅액: 1,000 / 소지금: 10,000


- 배팅 후 세 번째 카드의 수가 앞서 오픈된 카드 숫자의 사이에 있다면 배팅 금액의 10배가 되어
  소지금 추가

- 반대라면 소지금에서 배팅한 만큼 마이너스

※ 한 턴이 끝나고 사용된 카드는 버려져서 더 이상 사용할 수 없다.


게임 종료 조건: 소지금이 다 떨어지거나, 카드가 다 떨어지거나.

배팅 폭이 없음.


*/

void GetHP(int a, int b)
{
	a + b;
}

void SomeFunction()
{
	int HP = 1000;

	GetHP(HP, 100);
	cout << HP << endl;
	// Call By Value형식 함수이다.
}
/*
stack구조
스택 맨 위


GetHP함수 반환주소값
GetHP 함수
int HP
someFunction함수 반환주소값
someFunction 함수

main 함수

스택 맨 아래

*/

#define ARRAY_SIZE 30

void voidPointer();
void InitMatrix(int* a_pnMatrix, int a_nRow, int a_nCol, int a_ColCount); //스네이크 형식, a는 argument의 약자, 전달 인자로써만 기능을 하겠다
void PrintMatrix(int* a_pnMatrix, int a_nRow, int a_nCol, int a_ColCount);
void ArrPointer();


// inline: 알아도 그만, 몰라도 그만 / 단, 깊게는 찾아보지 말 것
// ㄴ inline을 쓰면 실행속도를 높일 수 있다. 
// void voidPointer()보다 inline void LinePrint()가 더 빠를 수도 있음
inline void LinePrint()
{
	cout << "=======================================" << endl;
}


void main()
{
	cout << "즐겁고 쉽게 재밌게 너무 최고야 -> 포인터" << endl;
	LinePrint();

	/*
	
	- 포인터 선언 방법 

	int Value = 0;             <- 메모리의 특정 영역에 4 바이트 공간 할당
	int* pnPointer = &Value;   <- Value가 할당된 메모리 공간의 첫 주소를 할당
	
	*/

	int valueA = 10;

	int* pValueA = &valueA;
	// 1번 참조할 수 있다.

	int** ppValueA = &pValueA; // 더블 포인터, *가 하나 더 붙으면 트리플 포인터
	// 2번 참조할 수 있다.
	// (int*) * 로 해석할 수 있음
	//	ㄴ int 포인터 변수를 참조하겠다.

	cout << ppValueA << endl;
	// pValueA의 주소값이 담겨있다. -> 

	cout << *(*ppValueA) << endl;
	//(*ppValueA)는 pValueA의 값을 참조한다 -> pValueA의 값(valueA의 주소값)
	// (*ppValueA) 밖에 *은 pValueA의 실제 값을 의미한다.
	// 10

	cout << &valueA << endl;
	// valueA의 주소값

	cout << valueA << endl;

	cout << pValueA << endl;
	// valueA의 주소값

	cout << *pValueA << endl;
	// valueA의 실제 값
	// *가 붙으면 참조하겠다(값을 가져오겠다)

	cout << &pValueA << endl;
	// pValueA의 주소값, valueA의 주소값을 저장하는게 아님

	LinePrint();

	/*
	- 포인터는 사용함에 있어 주의를 많이 요하는 문법

	int number;
	number = 100;

	//초기화를 명시해야 한다.
	int* pValueA;
	pValueA = &number; // 이렇게 하면 안 된다.

	- pValueA는 초기화를 하지 않았기 때문에 쓰레기 값을 가지고 있다.
	ㄴ 이 값은 어디에도 사용이 될 수도 있고 아닐 수도 있고... 답은 컴퓨터만 알고 있다.

	- 컴파일러 버전이 올라가면서 쓰레기 값 같은 경우 오류처리 하지 않고 넘어가 주는 경우가
	있지만 원칙적으로 오류가 맞다.

	- 포인터가 가르키는 값을 변경할 때는 꼭 확인을 요하고 변경을 해줘야 한다.

	★ 이러한 패턴은 예외처리를 진행할 때도 동일하게 수행된다.
	
	*/

	int* pValueC = NULL;

	pValueC = &valueA;

	// 방어적 코딩
	//	ㄴ 널이 아닌 경우에만 변경하겠다.
	if (pValueC != nullptr) // 상황에 맞게 변경하겠다.
	{
		*pValueC = 30;
	}

	LinePrint();

	/*
	★ 면접 문제 ★
	// 차이점, 특징, 언제 쓰이는지
	NULL VS nullptr

	- NULL은 엄밀히 말하면 포인터가 아니다.
	ㄴ 매크로 정의된 상수 0
	ㄴ NULL의 경우는 진짜 널을 가르키는 포인터가 아니라 숫자 0을 의미한다.

	- nullptr
	ㄴ 널 포인터 값을 나타내는 포인터 리터럴 -> 포인터를 표현하는 값 중에 NUll을 표현한 값
	ㄴ C++에서는 void*에서 다른 포인터 자료형으로 암시적 형변환이 발생하지 않기 때문에
	NULL을 포인터 초기화값으로 쓴다면 함수에 인자로 넘겨줄 때 에러가 발생한다. (불편)
	ㄴ 그렇기 때문에 C++11에서 추가된 nullptr을 통해서 구현을 하는게 확장성면에서는 좋다.	

	nullptr = 0 / 0에 주소 / NULL 주소

	C 관련된 문법 => NULL
	C++ 관련된 문법 => nullptr
	*/

	cout << "포인터 배열" << endl;

	int* pArrA[3];

	int numA = 10, numB = 20, numC = 30;
	int* pNumA = &numA;
	int* pNumB = &numB;
	int* pNumC = &numC;

	int* pArrB[] = { pNumA, pNumB, pNumC };
	int** dpArr = pArrB;

	// 오늘의 과제1.
	// 출력 3개의 값 유추, 이유를 주석으로 적어올 것
	cout << pNumA << endl;
	// numA의 주소값
	// 이유: 포인터 변수 pNumA에 numA의 주소값을 대입했기 때문에 numA의 주소값이 나온다.

	cout << pArrB << endl;
	// 배열의 0번째 인덱스인 pNumA의 값
	// 이유: 기본적으로 배열의 인덱스를 주지 않고 배열 그 자체를 찍으면
	// 배열의 0번째 인덱스의 값을 가져오게 된다.

	// 정답: 배열의 0번째 인덱스인 pNumA의 주소값
	// 이유: 그냥 배열이 아닌 포인터 변수가 들어간
	// 참조 형태의 배열은 주소값을 출력한다.

	cout << dpArr << endl;
	// 2번째와 마찬가지로 pArrB의 0번째 인덱스의 값

	// 정답: 배열의 0번째 인덱스인 pNumA의 주소값

	LinePrint();

	cout << "문자열 포인터" << endl;

	char str1[] = "My String"; // 변수
	const char* str2 = "Your String"; // 상수
	// 값은 바꿀 수 있지만 주소는 안 바뀐다.

	/*
	※ 난 너희가 이 개념을 바로 이해한다고 생각하지 않아...
	ㄴ 단, 포폴 전에는 어느 정도 이해를 했으면 좋겠구나.
	변수 형태 문자열 vs 상수 형태 문자열

	- char* 같은 경우에는 메모리 공간에 문자열 "Your String"이 저장되고 문자열의 첫번째
	문자 Y의 주소 값이 반환된다.

	- 두 문자열의 차이점은 아래와 같다.
	ㄴ 1. "My String"   -> 10개의 길이를 지닌 str1 배열
		ㄴ str1은 그 자체로 문자열 전체를 저장하는 배열
	ㄴ 2. "Your String" -> 포인터 변수 str2에 저장된 Your String
		ㄴ str2는 메모리상에 자동으로 저장된 Your String의 첫번째 문자를 단순히 가르키기만
		하는 포인터 변수

	- 배열이름 str은 계속해서 문자 M의 주소값이기 때문에 str1도 str2 문자열의 시작 주소값을
	담고 있다는 의미에서는 동일하다.

	- 단, 배열이름 str1은 계속해서 문자 M이 저장된 위치를 가리키는 상태이여야 하지만
	포인터 변수 str2는 다른 위치를 가리킬 수 있다.
	*/

	/*
	▶ 메모리 구성 영역

	- 컴퓨터는 다양한 메모리의 구성 영역을 가지고 있다.

	1. 코드 영역(휘발성 데이터)

	- 실행할 코드가 저장되는 메모리 공간이며 CPU는 코드 영역에 저장된 명령문들을 하나씩
	가져오면서 실행하는 구조를 가지고 있다.

	- 코드 영역은 운영체제에 의해서 관리되기 때문에 직접적으로 제어하는 것은 일반적으로 불가능(C++만 가능)

	C++만 가능한 이유(이제까지 했던 범위에서 C++만 가능이라고 적어둔 부분이 있음)가 OS의 주소값을 가져오면 되기 때문에.


	2. 데이터(휘발성 데이터)

	- 전역 변수와 static으로 선언되는 static 변수가 할당되는 공간

	- 프로그램 시작과 동시에 메모리 공간에 할당되어 프로그램 종료시까지 남아있는 특성이 있다.

	- 전역 변수, 정적 변수등 프로그램이 실행 될 때 할당되고 종료될 때 제거되는
	  영역이라고 할 수 있다.


	3. 스택(휘발성 데이터)

	- 지역 변수와 매개변수가 할당, 선언된 함수를 빠져 나가면 소멸 되는 영역

	- 시스템에 의해서 관리되는 영역

	4. 힙
	
	- 프로그래머에 의해서 관리되는 영역

	- 데이터 영역과 스택 영역에 할당되는 변수들은 생성과 소멸의 사이클이 정해져 있다.

	- 프로그래머가 원하는 시점에 변수를 할당하고 소멸할 수 있는 영역이 바로 힙
	ㄴ 프로그래머가 직접 할당하는 것이므로 프로그래머가 직접 소멸해 줘야 한다. 
		(C#에선 프로그래머가 할당은 할 수 있지만 프로그래머가 직접 소멸을 할 수 없고 컴퓨터가 해야한다)

	- 만약 깜빡하면 프로그램이 종료될 때 날라가기는 한다.


	▶ 동적 할당 (Dynamic Allocation)
	
	- 프로그램을 작성할 때 (컴파일 타임 or 디자인 타임(어떻게 디자인해서 어떻게 컴파일 할지) 메모리 필요량을 지정하는 정적 할당과는
	달리 실행 중에 필요한 만큼의 메모리를 할당하는 기법

	- 동적 할당된 메모리는 이름이 없는 변수라고 할 수 있다.

	- 정적인 메모리 영역을 차지하고 있으므로 일단 값을 기억할 수는 있지만 이름이 없으므로
	오로지 포인터로만 접근이 허용된다.

	★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
	★ 동적 할당시 주의점
	
	- 동적할당을 해두면 메모리에 올려진 상태로 유지가 된다.
		ㄴ 때문에 동적할당을 해놓고  사용이 끝난 시점에 반드시 해제를 해줘야 한다.

	
	 동적할당을 써야만 하는 이유
	
	- 게임을 만들다 보면 지역 변수도 아니니 전역변수도 아닌 변수가 필요할 경우가 있다.
		ㄴ EX: 함수가 매번 호출될 때마다 새롭게 할당되고 또 함수를 빠져나가도 유지되는 변수

	- 지역 변수를 쓰자니 함수가 끝나면 소멸이 되고, 전역 변수를 쓰자니 이전의 값을 덮어버리기
	때문에 문제가 발생한다.

	- 만약 최대 100개의 데이터를 저장해야 할 때 우리는 정적으로 100개를 할당해야 하지만
	40개의 데이터 밖에 안 들어오면 60개가 낭비되는 상황이 발생
		ㄴ 그렇기 때문에 메모리 관리를 위해서 들어오는 족족 할당하는 기법 -> 동적 할당
	
	sdd / hdd에 저장해야할 때 전문적인 용어로 파일 입출력이라고 한다.
	*/

	// 내가 쓰고 있는 코드는 스택영역에서 처리 하고 있었다.
	//Hip영역: 가용, 할당하는 영역
	// ㄴ 동적 메모리 공간
	// ㄴ Hip크기: 램 크기

	//Stack
	// ㄴ 정적 메모리 공간
	// ㄴ Stack의 크기: 1MB
	//		ㄴ 1MB를 넘기면 오버플로우가 발생

	// string이나 크기가 큰 배열을 stack에 넣으면 오버플로우가 발생하므로
	// hip영역에 할당해줘야 한다. 그럼 hip영역에 할당된 배열이나 문자열을
	// 주소값을 통해 불러올 수 있다.(포인터)

	/*
	2024.04.04
	▶ C / C++ 언어의 메모리 동적 할당 기법

	- malloc
	ㄴ C언어 동적 할당 키워드
	- new
	ㄴ C++ 언어 동적 할당 키워드

	★★★★ 면접 문제 ★★★★
	C 계열 언어에서 메모리 동적 할당시 주의사항

	1. 메모리 릭 (Memory Leak)
	ㄴ 메모리 누수
		ㄴ 불필요한 메모리가 제거되지 않고 계속 상주하는 경우
		

	2. 댕글링 포인터 (Dangling Pointer)
	ㄴ 이미 제거된 메모리를 가르키고 있는 경우 이를 댕글링 포인터라고 한다.
	ㄴ 댕글링 포인터가 가르키는 메모리는 더 이상 유효하지 않으며 보통 프로그래머에
	Premature Free(성급한 해제) 이놈도 뜻이 같다.
	ㄴ 예측 불가의 결과 유발 (메모리 접근시)
	ㄴ 보통은 메모리 해제 후, 해제된 메모리에 접근하거나 함수 호출에서 자동 변수를
	가르키는 포인터를 반환할 때 발생한다.

	- 이 외에도 댕글링 포인터는 메모리 접근 불가시 세그먼테이션 폴트 (Segmentation Fault) 라는 보안 위험을
	발생시키기 때문에 아주아주 위험하다
	*/

// 생성한다. -> new는 문법 그 자체 -> 그대로 써야 하고 변수의 맨 앞을 가르키고 있다.
int* countA = new int[3];
int* countB = new int;

for (int i = 0; i < 3; i++)
{
	countA[i] = i;
	*countB = i + 18;
}

for (int i = 0; i < 3; i++)
{
	cout << "카운트는? " << countA[i] << endl; // 0, 1, 2
}

cout << "coutn2의 값은? " << *countB << endl; // 20

// 삭제
delete[] countA;
delete countB;
}

void voidPointer()
{

}

void InitMatrix(int* a_pnMatrix, int a_nRow, int a_nCol, int a_ColCount)
{
	int nNumber = 0;
	int nMaxNumber = a_nCol * a_nRow;

	int nLoopCount = 0;
	int nDirection = 1;

	int nRowIndex = 0;
	int nColIndex = -1;

	while (nNumber < nMaxNumber)
	{
		int anValues[5] = { 0 };
		for (int i = 0; i < a_nCol - nLoopCount; ++i)
		{
			nColIndex += nDirection;
			int nindex = (nRowIndex * a_ColCount) + nColIndex;

			a_pnMatrix[nindex] = ++nNumber;

		}
	}
}

void PrintMatrix(int* a_pnMatrix, int a_nRow, int a_nCol, int a_ColCount)
{
}

void ArrPointer()
{
	int nSize = 0;

	cout << "정수 입력: " << endl;
	cin >> nSize;
}
